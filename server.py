import socket
from _thread import *
import pickle
from entities import player_instances, MAX_PLAYERS
server = '192.168.43.18'  # Assurez-vous que cette adresse est correcte
# server = ''
port = 5555
import sys
print(sys.version)
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
    s.bind((server, port))
    print(f"Server bound to {server}:{port}")
except socket.error as e:
    print(f"Socket error: {e}")

s.listen(MAX_PLAYERS)
print(f"Server listening, ready for up to {MAX_PLAYERS} players")

players = player_instances
print(f"Initial player list: {players}")


def threaded_client(conn, player):
    try:
        print("v1")
        print(f"Sending player {player} to client :", players[player])
        print(f"Sending player {player} to client :",
              pickle.dumps(players[player]))
        conn.send(pickle.dumps(players[player]))
        while True:
            print(f"true")
            print("Waiting for data...")
            raw_data = conn.recv(2048)
            print("Data received. Deserializing...", raw_data)
            print("pickle.loads(raw_data) :", pickle.loads(raw_data))
            test = b'\x16\x03\x01\x027\x01\x00\x023\x03\x03\xcah\xbdT\x9b\xbf\x87\x02z\x89\x80\x01\xc4>s\xd3da\x96\xae6\x16\xdd\xa8 \x89\xa0\x80\x97?\xa1\xd8 -\xde\xa9\x10\xb4\xa3I\x8b\xd7\x16\x1b&\'\xf6\x97\xca\x87&\xcd\x83q8%\x01\xd3s\xda\xe4o_`\x91\x00 JJ\x13\x01\x13\x02\x13\x03\xc0+\xc0/\xc0,\xc00\xcc\xa9\xcc\xa8\xc0\x13\xc0\x14\x00\x9c\x00\x9d\x00/\x005\x01\x00\x01\xca\xca\xca\x00\x00\xfe\r\x01\x1a\x00\x00\x01\x00\x01W\x00 \xc6\x87\xd9\xaa\x80\x92\x1e\xf8\x81hH\xb6\x90\xa0\xe6FG\xbdA\x03EK3/\xad\x94\xd7$\xe54\x95\x02\x00\xf0M\x8ee\xee\xd4\x97\xb4}l\xf0`\xef#\xa6\xb6\x92\xff\xe4\xd7\xfe\x81\xbf.khK\xb2\x9a\xee\xa0\xd8eq!v\x1f4\xa8\xac\xa4\xb4\x8a\xef\xc0\xf7\xa5k<&><\xf2\xd8\x17A\xa5n\xca\xb4\xaa)X\x19\x8f\xba`\x1b\x81\x88\xcc\xc3\n\x88\xa2Z\x83Fi]vt\x14[A\x06\x12v\x84\x19\xdaY\xa9\r\x9ep%\x16\x9af\xac\x8cQPu\x025\xfb\x89\x16E\xde6\x0b\xdcIM(\x87\xf4\xea\xcb\x86\xb2\xcc\xa4\x16}\xae\x0e*\x0f\xab\x99\xa8W\xc1\x07\xa3\x01\xce O\xfe\xb7o\xd1\x91lZ7\x8f\xe6\xd89\xfd\xea\xe3Kc?\x92\xf1\x1a\x14\xa5\xad\rd\xe6\xf6\xe0\xda\x87<\x8b\xb7\xd0\xe8\xc1d(\xd4\x0c\xc1n\x9a\rf%\x98#\xfbl\x19Lg\xd97gD\xb1\x07\xd1\x12%\x8f\xc3\x17\xf3S\xaa\x0e\xaf\x04\xd8\xb6\x8aZ})\x89\x1f\xa1\xff\xb4\x1aM\x7fW#\xc2\x8a\xf5g\xbf\xcch\xac\xd5\x0e\xff\x01\x00\x01\x00\x00\r\x00\x12\x00\x10\x04\x03\x08\x04\x04\x01\x05\x03\x08\x05\x05\x01\x08\x06\x06\x01\x00-\x00\x02\x01\x01\x003\x00+\x00)\x8a\x8a\x00\x01\x00\x00\x1d\x00 \x84I\x15m\x98}\xf7\xdc\xec\xd7N\x92K\xaf\xe4r@\xed\xdd\xe1\x1f\xc4\xc2\xe2l\x81\x84"\xec\xc0\xf1k\x00\x1b\x00\x03\x02\x00\x02\x00\x12\x00\x00\x00\x05\x00\x05\x01\x00\x00\x00\x00\x00\x10\x00\x0b\x00\t\x08http/1.1\x00+\x00\x07\x06\x8a\x8a\x03\x04\x03\x03\x00\x0b\x00\x02\x01\x00\x00\n\x00\n\x00\x08\x8a\x8a\x00\x1d\x00\x17\x00\x18Di\x00\x05\x00\x03\x02h2\x00#\x00\x00\x00\x17\x00\x00**\x00\x01\x00\x15\x03\x01\x00\x02\x02F'
            print("test", pickle.loads(test))
            data = pickle.loads(raw_data)
            print("Data deserialized.")
            print(f"Received data from player {player}: {data}")
            if not data:
                break
            players[player] = data
            reply = players[:player] + players[player+1:]
            print("pickle.dumps(reply) :", pickle.dumps(reply))
            conn.sendall(pickle.dumps(reply))
    except Exception as e:
        print(f"Error handling client {player}: {e}")
    finally:
        print(f"Connection with player {player} closed")
        conn.close()


currentPlayer = 0
while True:
    conn, addr = s.accept()
    print(f"Connected to {addr}, connection object: {conn}")
    if currentPlayer < MAX_PLAYERS:
        start_new_thread(threaded_client, (conn, currentPlayer))
        currentPlayer += 1
        print(f"Current player count: {currentPlayer}")
    else:
        print("Server full: already reached maximum player count.")
